"use strict";
// tslint:disable
/**
 * YNAB API Endpoints
 * Our API uses a REST based design, leverages the JSON data format, and relies upon HTTPS for transport. We respond with meaningful HTTP response codes and if an error occurs, we include error details in the response body.  API Documentation is at https://api.youneedabudget.com
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const url = require("url");
// Requiring portable-fetch like this ensures that we have a global fetch function
// That makes it easier to override with modules like fetch-mock
require("portable-fetch");
const USER_AGENT = "api_client/js/1.11.0";
function convertDateToFullDateStringFormat(date) {
    // Convert to RFC 3339 "full-date" format, like "2017-11-27"
    if (date instanceof Date) {
        return date.toISOString().substring(0, 10);
    }
    else {
        return date;
    }
}
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace Account
 */
var Account;
(function (Account) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["Checking"] = 'checking'] = "Checking";
        TypeEnum[TypeEnum["Savings"] = 'savings'] = "Savings";
        TypeEnum[TypeEnum["Cash"] = 'cash'] = "Cash";
        TypeEnum[TypeEnum["CreditCard"] = 'creditCard'] = "CreditCard";
        TypeEnum[TypeEnum["LineOfCredit"] = 'lineOfCredit'] = "LineOfCredit";
        TypeEnum[TypeEnum["OtherAsset"] = 'otherAsset'] = "OtherAsset";
        TypeEnum[TypeEnum["OtherLiability"] = 'otherLiability'] = "OtherLiability";
        TypeEnum[TypeEnum["PayPal"] = 'payPal'] = "PayPal";
        TypeEnum[TypeEnum["MerchantAccount"] = 'merchantAccount'] = "MerchantAccount";
        TypeEnum[TypeEnum["InvestmentAccount"] = 'investmentAccount'] = "InvestmentAccount";
        TypeEnum[TypeEnum["Mortgage"] = 'mortgage'] = "Mortgage";
    })(TypeEnum = Account.TypeEnum || (Account.TypeEnum = {}));
})(Account = exports.Account || (exports.Account = {}));
/**
 * @export
 * @namespace Category
 */
var Category;
(function (Category) {
    /**
     * @export
     * @enum {string}
     */
    let GoalTypeEnum;
    (function (GoalTypeEnum) {
        GoalTypeEnum[GoalTypeEnum["TB"] = 'TB'] = "TB";
        GoalTypeEnum[GoalTypeEnum["TBD"] = 'TBD'] = "TBD";
        GoalTypeEnum[GoalTypeEnum["MF"] = 'MF'] = "MF";
    })(GoalTypeEnum = Category.GoalTypeEnum || (Category.GoalTypeEnum = {}));
})(Category = exports.Category || (exports.Category = {}));
/**
 * @export
 * @namespace SaveTransaction
 */
var SaveTransaction;
(function (SaveTransaction) {
    /**
     * @export
     * @enum {string}
     */
    let ClearedEnum;
    (function (ClearedEnum) {
        ClearedEnum[ClearedEnum["Cleared"] = 'cleared'] = "Cleared";
        ClearedEnum[ClearedEnum["Uncleared"] = 'uncleared'] = "Uncleared";
        ClearedEnum[ClearedEnum["Reconciled"] = 'reconciled'] = "Reconciled";
    })(ClearedEnum = SaveTransaction.ClearedEnum || (SaveTransaction.ClearedEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let FlagColorEnum;
    (function (FlagColorEnum) {
        FlagColorEnum[FlagColorEnum["Red"] = 'red'] = "Red";
        FlagColorEnum[FlagColorEnum["Orange"] = 'orange'] = "Orange";
        FlagColorEnum[FlagColorEnum["Yellow"] = 'yellow'] = "Yellow";
        FlagColorEnum[FlagColorEnum["Green"] = 'green'] = "Green";
        FlagColorEnum[FlagColorEnum["Blue"] = 'blue'] = "Blue";
        FlagColorEnum[FlagColorEnum["Purple"] = 'purple'] = "Purple";
    })(FlagColorEnum = SaveTransaction.FlagColorEnum || (SaveTransaction.FlagColorEnum = {}));
})(SaveTransaction = exports.SaveTransaction || (exports.SaveTransaction = {}));
/**
 * @export
 * @namespace ScheduledTransactionSummary
 */
var ScheduledTransactionSummary;
(function (ScheduledTransactionSummary) {
    /**
     * @export
     * @enum {string}
     */
    let FrequencyEnum;
    (function (FrequencyEnum) {
        FrequencyEnum[FrequencyEnum["Never"] = 'never'] = "Never";
        FrequencyEnum[FrequencyEnum["Daily"] = 'daily'] = "Daily";
        FrequencyEnum[FrequencyEnum["Weekly"] = 'weekly'] = "Weekly";
        FrequencyEnum[FrequencyEnum["EveryOtherWeek"] = 'everyOtherWeek'] = "EveryOtherWeek";
        FrequencyEnum[FrequencyEnum["TwiceAMonth"] = 'twiceAMonth'] = "TwiceAMonth";
        FrequencyEnum[FrequencyEnum["Every4Weeks"] = 'every4Weeks'] = "Every4Weeks";
        FrequencyEnum[FrequencyEnum["Monthly"] = 'monthly'] = "Monthly";
        FrequencyEnum[FrequencyEnum["EveryOtherMonth"] = 'everyOtherMonth'] = "EveryOtherMonth";
        FrequencyEnum[FrequencyEnum["Every3Months"] = 'every3Months'] = "Every3Months";
        FrequencyEnum[FrequencyEnum["Every4Months"] = 'every4Months'] = "Every4Months";
        FrequencyEnum[FrequencyEnum["TwiceAYear"] = 'twiceAYear'] = "TwiceAYear";
        FrequencyEnum[FrequencyEnum["Yearly"] = 'yearly'] = "Yearly";
        FrequencyEnum[FrequencyEnum["EveryOtherYear"] = 'everyOtherYear'] = "EveryOtherYear";
    })(FrequencyEnum = ScheduledTransactionSummary.FrequencyEnum || (ScheduledTransactionSummary.FrequencyEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let FlagColorEnum;
    (function (FlagColorEnum) {
        FlagColorEnum[FlagColorEnum["Red"] = 'red'] = "Red";
        FlagColorEnum[FlagColorEnum["Orange"] = 'orange'] = "Orange";
        FlagColorEnum[FlagColorEnum["Yellow"] = 'yellow'] = "Yellow";
        FlagColorEnum[FlagColorEnum["Green"] = 'green'] = "Green";
        FlagColorEnum[FlagColorEnum["Blue"] = 'blue'] = "Blue";
        FlagColorEnum[FlagColorEnum["Purple"] = 'purple'] = "Purple";
    })(FlagColorEnum = ScheduledTransactionSummary.FlagColorEnum || (ScheduledTransactionSummary.FlagColorEnum = {}));
})(ScheduledTransactionSummary = exports.ScheduledTransactionSummary || (exports.ScheduledTransactionSummary = {}));
/**
 * @export
 * @namespace TransactionSummary
 */
var TransactionSummary;
(function (TransactionSummary) {
    /**
     * @export
     * @enum {string}
     */
    let ClearedEnum;
    (function (ClearedEnum) {
        ClearedEnum[ClearedEnum["Cleared"] = 'cleared'] = "Cleared";
        ClearedEnum[ClearedEnum["Uncleared"] = 'uncleared'] = "Uncleared";
        ClearedEnum[ClearedEnum["Reconciled"] = 'reconciled'] = "Reconciled";
    })(ClearedEnum = TransactionSummary.ClearedEnum || (TransactionSummary.ClearedEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let FlagColorEnum;
    (function (FlagColorEnum) {
        FlagColorEnum[FlagColorEnum["Red"] = 'red'] = "Red";
        FlagColorEnum[FlagColorEnum["Orange"] = 'orange'] = "Orange";
        FlagColorEnum[FlagColorEnum["Yellow"] = 'yellow'] = "Yellow";
        FlagColorEnum[FlagColorEnum["Green"] = 'green'] = "Green";
        FlagColorEnum[FlagColorEnum["Blue"] = 'blue'] = "Blue";
        FlagColorEnum[FlagColorEnum["Purple"] = 'purple'] = "Purple";
    })(FlagColorEnum = TransactionSummary.FlagColorEnum || (TransactionSummary.FlagColorEnum = {}));
})(TransactionSummary = exports.TransactionSummary || (exports.TransactionSummary = {}));
/**
 * @export
 * @namespace HybridTransaction
 */
var HybridTransaction;
(function (HybridTransaction) {
    /**
     * @export
     * @enum {string}
     */
    let ClearedEnum;
    (function (ClearedEnum) {
        ClearedEnum[ClearedEnum["Cleared"] = 'cleared'] = "Cleared";
        ClearedEnum[ClearedEnum["Uncleared"] = 'uncleared'] = "Uncleared";
        ClearedEnum[ClearedEnum["Reconciled"] = 'reconciled'] = "Reconciled";
    })(ClearedEnum = HybridTransaction.ClearedEnum || (HybridTransaction.ClearedEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let FlagColorEnum;
    (function (FlagColorEnum) {
        FlagColorEnum[FlagColorEnum["Red"] = 'red'] = "Red";
        FlagColorEnum[FlagColorEnum["Orange"] = 'orange'] = "Orange";
        FlagColorEnum[FlagColorEnum["Yellow"] = 'yellow'] = "Yellow";
        FlagColorEnum[FlagColorEnum["Green"] = 'green'] = "Green";
        FlagColorEnum[FlagColorEnum["Blue"] = 'blue'] = "Blue";
        FlagColorEnum[FlagColorEnum["Purple"] = 'purple'] = "Purple";
    })(FlagColorEnum = HybridTransaction.FlagColorEnum || (HybridTransaction.FlagColorEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["Transaction"] = 'transaction'] = "Transaction";
        TypeEnum[TypeEnum["Subtransaction"] = 'subtransaction'] = "Subtransaction";
    })(TypeEnum = HybridTransaction.TypeEnum || (HybridTransaction.TypeEnum = {}));
})(HybridTransaction = exports.HybridTransaction || (exports.HybridTransaction = {}));
/**
 * @export
 * @namespace ScheduledTransactionDetail
 */
var ScheduledTransactionDetail;
(function (ScheduledTransactionDetail) {
    /**
     * @export
     * @enum {string}
     */
    let FrequencyEnum;
    (function (FrequencyEnum) {
        FrequencyEnum[FrequencyEnum["Never"] = 'never'] = "Never";
        FrequencyEnum[FrequencyEnum["Daily"] = 'daily'] = "Daily";
        FrequencyEnum[FrequencyEnum["Weekly"] = 'weekly'] = "Weekly";
        FrequencyEnum[FrequencyEnum["EveryOtherWeek"] = 'everyOtherWeek'] = "EveryOtherWeek";
        FrequencyEnum[FrequencyEnum["TwiceAMonth"] = 'twiceAMonth'] = "TwiceAMonth";
        FrequencyEnum[FrequencyEnum["Every4Weeks"] = 'every4Weeks'] = "Every4Weeks";
        FrequencyEnum[FrequencyEnum["Monthly"] = 'monthly'] = "Monthly";
        FrequencyEnum[FrequencyEnum["EveryOtherMonth"] = 'everyOtherMonth'] = "EveryOtherMonth";
        FrequencyEnum[FrequencyEnum["Every3Months"] = 'every3Months'] = "Every3Months";
        FrequencyEnum[FrequencyEnum["Every4Months"] = 'every4Months'] = "Every4Months";
        FrequencyEnum[FrequencyEnum["TwiceAYear"] = 'twiceAYear'] = "TwiceAYear";
        FrequencyEnum[FrequencyEnum["Yearly"] = 'yearly'] = "Yearly";
        FrequencyEnum[FrequencyEnum["EveryOtherYear"] = 'everyOtherYear'] = "EveryOtherYear";
    })(FrequencyEnum = ScheduledTransactionDetail.FrequencyEnum || (ScheduledTransactionDetail.FrequencyEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let FlagColorEnum;
    (function (FlagColorEnum) {
        FlagColorEnum[FlagColorEnum["Red"] = 'red'] = "Red";
        FlagColorEnum[FlagColorEnum["Orange"] = 'orange'] = "Orange";
        FlagColorEnum[FlagColorEnum["Yellow"] = 'yellow'] = "Yellow";
        FlagColorEnum[FlagColorEnum["Green"] = 'green'] = "Green";
        FlagColorEnum[FlagColorEnum["Blue"] = 'blue'] = "Blue";
        FlagColorEnum[FlagColorEnum["Purple"] = 'purple'] = "Purple";
    })(FlagColorEnum = ScheduledTransactionDetail.FlagColorEnum || (ScheduledTransactionDetail.FlagColorEnum = {}));
})(ScheduledTransactionDetail = exports.ScheduledTransactionDetail || (exports.ScheduledTransactionDetail = {}));
/**
 * @export
 * @namespace TransactionDetail
 */
var TransactionDetail;
(function (TransactionDetail) {
    /**
     * @export
     * @enum {string}
     */
    let ClearedEnum;
    (function (ClearedEnum) {
        ClearedEnum[ClearedEnum["Cleared"] = 'cleared'] = "Cleared";
        ClearedEnum[ClearedEnum["Uncleared"] = 'uncleared'] = "Uncleared";
        ClearedEnum[ClearedEnum["Reconciled"] = 'reconciled'] = "Reconciled";
    })(ClearedEnum = TransactionDetail.ClearedEnum || (TransactionDetail.ClearedEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let FlagColorEnum;
    (function (FlagColorEnum) {
        FlagColorEnum[FlagColorEnum["Red"] = 'red'] = "Red";
        FlagColorEnum[FlagColorEnum["Orange"] = 'orange'] = "Orange";
        FlagColorEnum[FlagColorEnum["Yellow"] = 'yellow'] = "Yellow";
        FlagColorEnum[FlagColorEnum["Green"] = 'green'] = "Green";
        FlagColorEnum[FlagColorEnum["Blue"] = 'blue'] = "Blue";
        FlagColorEnum[FlagColorEnum["Purple"] = 'purple'] = "Purple";
    })(FlagColorEnum = TransactionDetail.FlagColorEnum || (TransactionDetail.FlagColorEnum = {}));
})(TransactionDetail = exports.TransactionDetail || (exports.TransactionDetail = {}));
/**
 * AccountsApi - fetch parameter creator
 * @export
 */
exports.AccountsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} account_id - The id of the account
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budget_id, account_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getAccountById.');
            }
            // verify required parameter 'account_id' is not null or undefined
            if (account_id === null || account_id === undefined) {
                throw new RequiredError('account_id', 'Required parameter account_id was null or undefined when calling getAccountById.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts/{account_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(account_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budget_id, last_knowledge_of_server, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getAccounts.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (last_knowledge_of_server !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = last_knowledge_of_server;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AccountsApi - functional programming interface
 * @export
 */
exports.AccountsApiFp = function (configuration) {
    return {
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} account_id - The id of the account
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budget_id, account_id, options) {
            const localVarFetchArgs = exports.AccountsApiFetchParamCreator(configuration).getAccountById(budget_id, account_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budget_id, last_knowledge_of_server, options) {
            const localVarFetchArgs = exports.AccountsApiFetchParamCreator(configuration).getAccounts(budget_id, last_knowledge_of_server, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * AccountsApi - factory interface
 * @export
 */
exports.AccountsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} account_id - The id of the account
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budget_id, account_id, options) {
            return exports.AccountsApiFp(configuration).getAccountById(budget_id, account_id, options)();
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budget_id, last_knowledge_of_server, options) {
            return exports.AccountsApiFp(configuration).getAccounts(budget_id, last_knowledge_of_server, options)();
        },
    };
};
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
class AccountsApi extends BaseAPI {
    /**
     * Returns a single account
     * @summary Single account
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {string} account_id - The id of the account
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getAccountById(budget_id, account_id, options) {
        return exports.AccountsApiFp(this.configuration).getAccountById(budget_id, account_id, options)();
    }
    /**
     * Returns all accounts
     * @summary Account list
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getAccounts(budget_id, last_knowledge_of_server, options) {
        return exports.AccountsApiFp(this.configuration).getAccounts(budget_id, last_knowledge_of_server, options)();
    }
}
exports.AccountsApi = AccountsApi;
/**
 * BudgetsApi - fetch parameter creator
 * @export
 */
exports.BudgetsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetById(budget_id, last_knowledge_of_server, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getBudgetById.');
            }
            const localVarPath = `/budgets/{budget_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (last_knowledge_of_server !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = last_knowledge_of_server;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns settings for a budget
         * @summary Budget Settings
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetSettingsById(budget_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getBudgetSettingsById.');
            }
            const localVarPath = `/budgets/{budget_id}/settings`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns budgets list with summary information
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options = {}) {
            const localVarPath = `/budgets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BudgetsApi - functional programming interface
 * @export
 */
exports.BudgetsApiFp = function (configuration) {
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetById(budget_id, last_knowledge_of_server, options) {
            const localVarFetchArgs = exports.BudgetsApiFetchParamCreator(configuration).getBudgetById(budget_id, last_knowledge_of_server, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns settings for a budget
         * @summary Budget Settings
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetSettingsById(budget_id, options) {
            const localVarFetchArgs = exports.BudgetsApiFetchParamCreator(configuration).getBudgetSettingsById(budget_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns budgets list with summary information
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options) {
            const localVarFetchArgs = exports.BudgetsApiFetchParamCreator(configuration).getBudgets(options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * BudgetsApi - factory interface
 * @export
 */
exports.BudgetsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetById(budget_id, last_knowledge_of_server, options) {
            return exports.BudgetsApiFp(configuration).getBudgetById(budget_id, last_knowledge_of_server, options)();
        },
        /**
         * Returns settings for a budget
         * @summary Budget Settings
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetSettingsById(budget_id, options) {
            return exports.BudgetsApiFp(configuration).getBudgetSettingsById(budget_id, options)();
        },
        /**
         * Returns budgets list with summary information
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options) {
            return exports.BudgetsApiFp(configuration).getBudgets(options)();
        },
    };
};
/**
 * BudgetsApi - object-oriented interface
 * @export
 * @class BudgetsApi
 * @extends {BaseAPI}
 */
class BudgetsApi extends BaseAPI {
    /**
     * Returns a single budget with all related entities.  This resource is effectively a full budget export.
     * @summary Single budget
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    getBudgetById(budget_id, last_knowledge_of_server, options) {
        return exports.BudgetsApiFp(this.configuration).getBudgetById(budget_id, last_knowledge_of_server, options)();
    }
    /**
     * Returns settings for a budget
     * @summary Budget Settings
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    getBudgetSettingsById(budget_id, options) {
        return exports.BudgetsApiFp(this.configuration).getBudgetSettingsById(budget_id, options)();
    }
    /**
     * Returns budgets list with summary information
     * @summary List budgets
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    getBudgets(options) {
        return exports.BudgetsApiFp(this.configuration).getBudgets(options)();
    }
}
exports.BudgetsApi = BudgetsApi;
/**
 * CategoriesApi - fetch parameter creator
 * @export
 */
exports.CategoriesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns all categories grouped by category group.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary List categories
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budget_id, last_knowledge_of_server, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getCategories.');
            }
            const localVarPath = `/budgets/{budget_id}/categories`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (last_knowledge_of_server !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = last_knowledge_of_server;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single category.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary Single category
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} category_id - The id of the category
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budget_id, category_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getCategoryById.');
            }
            // verify required parameter 'category_id' is not null or undefined
            if (category_id === null || category_id === undefined) {
                throw new RequiredError('category_id', 'Required parameter category_id was null or undefined when calling getCategoryById.');
            }
            const localVarPath = `/budgets/{budget_id}/categories/{category_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(category_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single category for a specific budget month.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary Single category for a specific budget month
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {Date} month - The budget month in ISO format (e.g. 2016-12-01) (\"current\" can also be used to specify the current calendar month (UTC))
         * @param {string} category_id - The id of the category
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getMonthCategoryById(budget_id, month, category_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getMonthCategoryById.');
            }
            // verify required parameter 'month' is not null or undefined
            if (month === null || month === undefined) {
                throw new RequiredError('month', 'Required parameter month was null or undefined when calling getMonthCategoryById.');
            }
            // verify required parameter 'category_id' is not null or undefined
            if (category_id === null || category_id === undefined) {
                throw new RequiredError('category_id', 'Required parameter category_id was null or undefined when calling getMonthCategoryById.');
            }
            const localVarPath = `/budgets/{budget_id}/months/{month}/categories/{category_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"month"}}`, encodeURIComponent(convertDateToFullDateStringFormat(month)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(category_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a category for a specific month
         * @summary Update a category for a specific month
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {Date} month - The budget month in ISO format (e.g. 2016-12-01) (\"current\" can also be used to specify the current calendar month (UTC))
         * @param {string} category_id - The id of the category
         * @param {SaveMonthCategoryWrapper} data - The category to update
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateMonthCategory(budget_id, month, category_id, data, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling updateMonthCategory.');
            }
            // verify required parameter 'month' is not null or undefined
            if (month === null || month === undefined) {
                throw new RequiredError('month', 'Required parameter month was null or undefined when calling updateMonthCategory.');
            }
            // verify required parameter 'category_id' is not null or undefined
            if (category_id === null || category_id === undefined) {
                throw new RequiredError('category_id', 'Required parameter category_id was null or undefined when calling updateMonthCategory.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data', 'Required parameter data was null or undefined when calling updateMonthCategory.');
            }
            const localVarPath = `/budgets/{budget_id}/months/{month}/categories/{category_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"month"}}`, encodeURIComponent(convertDateToFullDateStringFormat(month)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(category_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(data || {});
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CategoriesApi - functional programming interface
 * @export
 */
exports.CategoriesApiFp = function (configuration) {
    return {
        /**
         * Returns all categories grouped by category group.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary List categories
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budget_id, last_knowledge_of_server, options) {
            const localVarFetchArgs = exports.CategoriesApiFetchParamCreator(configuration).getCategories(budget_id, last_knowledge_of_server, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns a single category.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary Single category
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} category_id - The id of the category
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budget_id, category_id, options) {
            const localVarFetchArgs = exports.CategoriesApiFetchParamCreator(configuration).getCategoryById(budget_id, category_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns a single category for a specific budget month.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary Single category for a specific budget month
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {Date} month - The budget month in ISO format (e.g. 2016-12-01) (\"current\" can also be used to specify the current calendar month (UTC))
         * @param {string} category_id - The id of the category
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getMonthCategoryById(budget_id, month, category_id, options) {
            const localVarFetchArgs = exports.CategoriesApiFetchParamCreator(configuration).getMonthCategoryById(budget_id, month, category_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Update a category for a specific month
         * @summary Update a category for a specific month
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {Date} month - The budget month in ISO format (e.g. 2016-12-01) (\"current\" can also be used to specify the current calendar month (UTC))
         * @param {string} category_id - The id of the category
         * @param {SaveMonthCategoryWrapper} data - The category to update
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateMonthCategory(budget_id, month, category_id, data, options) {
            const localVarFetchArgs = exports.CategoriesApiFetchParamCreator(configuration).updateMonthCategory(budget_id, month, category_id, data, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * CategoriesApi - factory interface
 * @export
 */
exports.CategoriesApiFactory = function (configuration) {
    return {
        /**
         * Returns all categories grouped by category group.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary List categories
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budget_id, last_knowledge_of_server, options) {
            return exports.CategoriesApiFp(configuration).getCategories(budget_id, last_knowledge_of_server, options)();
        },
        /**
         * Returns a single category.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary Single category
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} category_id - The id of the category
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budget_id, category_id, options) {
            return exports.CategoriesApiFp(configuration).getCategoryById(budget_id, category_id, options)();
        },
        /**
         * Returns a single category for a specific budget month.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary Single category for a specific budget month
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {Date} month - The budget month in ISO format (e.g. 2016-12-01) (\"current\" can also be used to specify the current calendar month (UTC))
         * @param {string} category_id - The id of the category
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getMonthCategoryById(budget_id, month, category_id, options) {
            return exports.CategoriesApiFp(configuration).getMonthCategoryById(budget_id, month, category_id, options)();
        },
        /**
         * Update a category for a specific month
         * @summary Update a category for a specific month
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {Date} month - The budget month in ISO format (e.g. 2016-12-01) (\"current\" can also be used to specify the current calendar month (UTC))
         * @param {string} category_id - The id of the category
         * @param {SaveMonthCategoryWrapper} data - The category to update
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateMonthCategory(budget_id, month, category_id, data, options) {
            return exports.CategoriesApiFp(configuration).updateMonthCategory(budget_id, month, category_id, data, options)();
        },
    };
};
/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
class CategoriesApi extends BaseAPI {
    /**
     * Returns all categories grouped by category group.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
     * @summary List categories
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    getCategories(budget_id, last_knowledge_of_server, options) {
        return exports.CategoriesApiFp(this.configuration).getCategories(budget_id, last_knowledge_of_server, options)();
    }
    /**
     * Returns a single category.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
     * @summary Single category
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {string} category_id - The id of the category
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    getCategoryById(budget_id, category_id, options) {
        return exports.CategoriesApiFp(this.configuration).getCategoryById(budget_id, category_id, options)();
    }
    /**
     * Returns a single category for a specific budget month.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
     * @summary Single category for a specific budget month
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {Date} month - The budget month in ISO format (e.g. 2016-12-01) (\"current\" can also be used to specify the current calendar month (UTC))
     * @param {string} category_id - The id of the category
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    getMonthCategoryById(budget_id, month, category_id, options) {
        return exports.CategoriesApiFp(this.configuration).getMonthCategoryById(budget_id, month, category_id, options)();
    }
    /**
     * Update a category for a specific month
     * @summary Update a category for a specific month
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {Date} month - The budget month in ISO format (e.g. 2016-12-01) (\"current\" can also be used to specify the current calendar month (UTC))
     * @param {string} category_id - The id of the category
     * @param {SaveMonthCategoryWrapper} data - The category to update
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    updateMonthCategory(budget_id, month, category_id, data, options) {
        return exports.CategoriesApiFp(this.configuration).updateMonthCategory(budget_id, month, category_id, data, options)();
    }
}
exports.CategoriesApi = CategoriesApi;
/**
 * DeprecatedApi - fetch parameter creator
 * @export
 */
exports.DeprecatedApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates multiple transactions.  Although this endpoint is still supported, it is recommended to use 'POST /budgets/{budget_id}/transactions' to create multiple transactions.
         * @summary Bulk create transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {BulkTransactions} transactions - The list of transactions to create
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        bulkCreateTransactions(budget_id, transactions, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling bulkCreateTransactions.');
            }
            // verify required parameter 'transactions' is not null or undefined
            if (transactions === null || transactions === undefined) {
                throw new RequiredError('transactions', 'Required parameter transactions was null or undefined when calling bulkCreateTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions/bulk`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(transactions || {});
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DeprecatedApi - functional programming interface
 * @export
 */
exports.DeprecatedApiFp = function (configuration) {
    return {
        /**
         * Creates multiple transactions.  Although this endpoint is still supported, it is recommended to use 'POST /budgets/{budget_id}/transactions' to create multiple transactions.
         * @summary Bulk create transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {BulkTransactions} transactions - The list of transactions to create
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        bulkCreateTransactions(budget_id, transactions, options) {
            const localVarFetchArgs = exports.DeprecatedApiFetchParamCreator(configuration).bulkCreateTransactions(budget_id, transactions, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * DeprecatedApi - factory interface
 * @export
 */
exports.DeprecatedApiFactory = function (configuration) {
    return {
        /**
         * Creates multiple transactions.  Although this endpoint is still supported, it is recommended to use 'POST /budgets/{budget_id}/transactions' to create multiple transactions.
         * @summary Bulk create transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {BulkTransactions} transactions - The list of transactions to create
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        bulkCreateTransactions(budget_id, transactions, options) {
            return exports.DeprecatedApiFp(configuration).bulkCreateTransactions(budget_id, transactions, options)();
        },
    };
};
/**
 * DeprecatedApi - object-oriented interface
 * @export
 * @class DeprecatedApi
 * @extends {BaseAPI}
 */
class DeprecatedApi extends BaseAPI {
    /**
     * Creates multiple transactions.  Although this endpoint is still supported, it is recommended to use 'POST /budgets/{budget_id}/transactions' to create multiple transactions.
     * @summary Bulk create transactions
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {BulkTransactions} transactions - The list of transactions to create
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof DeprecatedApi
     */
    bulkCreateTransactions(budget_id, transactions, options) {
        return exports.DeprecatedApiFp(this.configuration).bulkCreateTransactions(budget_id, transactions, options)();
    }
}
exports.DeprecatedApi = DeprecatedApi;
/**
 * MonthsApi - fetch parameter creator
 * @export
 */
exports.MonthsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {Date} month - The budget month in ISO format (e.g. 2016-12-01) (\"current\" can also be used to specify the current calendar month (UTC))
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budget_id, month, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getBudgetMonth.');
            }
            // verify required parameter 'month' is not null or undefined
            if (month === null || month === undefined) {
                throw new RequiredError('month', 'Required parameter month was null or undefined when calling getBudgetMonth.');
            }
            const localVarPath = `/budgets/{budget_id}/months/{month}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"month"}}`, encodeURIComponent(convertDateToFullDateStringFormat(month)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budget_id, last_knowledge_of_server, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getBudgetMonths.');
            }
            const localVarPath = `/budgets/{budget_id}/months`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (last_knowledge_of_server !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = last_knowledge_of_server;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MonthsApi - functional programming interface
 * @export
 */
exports.MonthsApiFp = function (configuration) {
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {Date} month - The budget month in ISO format (e.g. 2016-12-01) (\"current\" can also be used to specify the current calendar month (UTC))
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budget_id, month, options) {
            const localVarFetchArgs = exports.MonthsApiFetchParamCreator(configuration).getBudgetMonth(budget_id, month, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budget_id, last_knowledge_of_server, options) {
            const localVarFetchArgs = exports.MonthsApiFetchParamCreator(configuration).getBudgetMonths(budget_id, last_knowledge_of_server, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * MonthsApi - factory interface
 * @export
 */
exports.MonthsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {Date} month - The budget month in ISO format (e.g. 2016-12-01) (\"current\" can also be used to specify the current calendar month (UTC))
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budget_id, month, options) {
            return exports.MonthsApiFp(configuration).getBudgetMonth(budget_id, month, options)();
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budget_id, last_knowledge_of_server, options) {
            return exports.MonthsApiFp(configuration).getBudgetMonths(budget_id, last_knowledge_of_server, options)();
        },
    };
};
/**
 * MonthsApi - object-oriented interface
 * @export
 * @class MonthsApi
 * @extends {BaseAPI}
 */
class MonthsApi extends BaseAPI {
    /**
     * Returns a single budget month
     * @summary Single budget month
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {Date} month - The budget month in ISO format (e.g. 2016-12-01) (\"current\" can also be used to specify the current calendar month (UTC))
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof MonthsApi
     */
    getBudgetMonth(budget_id, month, options) {
        return exports.MonthsApiFp(this.configuration).getBudgetMonth(budget_id, month, options)();
    }
    /**
     * Returns all budget months
     * @summary List budget months
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof MonthsApi
     */
    getBudgetMonths(budget_id, last_knowledge_of_server, options) {
        return exports.MonthsApiFp(this.configuration).getBudgetMonths(budget_id, last_knowledge_of_server, options)();
    }
}
exports.MonthsApi = MonthsApi;
/**
 * PayeeLocationsApi - fetch parameter creator
 * @export
 */
exports.PayeeLocationsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} payee_location_id - id of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budget_id, payee_location_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getPayeeLocationById.');
            }
            // verify required parameter 'payee_location_id' is not null or undefined
            if (payee_location_id === null || payee_location_id === undefined) {
                throw new RequiredError('payee_location_id', 'Required parameter payee_location_id was null or undefined when calling getPayeeLocationById.');
            }
            const localVarPath = `/budgets/{budget_id}/payee_locations/{payee_location_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"payee_location_id"}}`, encodeURIComponent(String(payee_location_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budget_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getPayeeLocations.');
            }
            const localVarPath = `/budgets/{budget_id}/payee_locations`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payee locations for the specified payee
         * @summary List locations for a payee
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} payee_id - id of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budget_id, payee_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getPayeeLocationsByPayee.');
            }
            // verify required parameter 'payee_id' is not null or undefined
            if (payee_id === null || payee_id === undefined) {
                throw new RequiredError('payee_id', 'Required parameter payee_id was null or undefined when calling getPayeeLocationsByPayee.');
            }
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}/payee_locations`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payee_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PayeeLocationsApi - functional programming interface
 * @export
 */
exports.PayeeLocationsApiFp = function (configuration) {
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} payee_location_id - id of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budget_id, payee_location_id, options) {
            const localVarFetchArgs = exports.PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocationById(budget_id, payee_location_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budget_id, options) {
            const localVarFetchArgs = exports.PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocations(budget_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all payee locations for the specified payee
         * @summary List locations for a payee
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} payee_id - id of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budget_id, payee_id, options) {
            const localVarFetchArgs = exports.PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocationsByPayee(budget_id, payee_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * PayeeLocationsApi - factory interface
 * @export
 */
exports.PayeeLocationsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} payee_location_id - id of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budget_id, payee_location_id, options) {
            return exports.PayeeLocationsApiFp(configuration).getPayeeLocationById(budget_id, payee_location_id, options)();
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budget_id, options) {
            return exports.PayeeLocationsApiFp(configuration).getPayeeLocations(budget_id, options)();
        },
        /**
         * Returns all payee locations for the specified payee
         * @summary List locations for a payee
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} payee_id - id of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budget_id, payee_id, options) {
            return exports.PayeeLocationsApiFp(configuration).getPayeeLocationsByPayee(budget_id, payee_id, options)();
        },
    };
};
/**
 * PayeeLocationsApi - object-oriented interface
 * @export
 * @class PayeeLocationsApi
 * @extends {BaseAPI}
 */
class PayeeLocationsApi extends BaseAPI {
    /**
     * Returns a single payee location
     * @summary Single payee location
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {string} payee_location_id - id of payee location
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    getPayeeLocationById(budget_id, payee_location_id, options) {
        return exports.PayeeLocationsApiFp(this.configuration).getPayeeLocationById(budget_id, payee_location_id, options)();
    }
    /**
     * Returns all payee locations
     * @summary List payee locations
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    getPayeeLocations(budget_id, options) {
        return exports.PayeeLocationsApiFp(this.configuration).getPayeeLocations(budget_id, options)();
    }
    /**
     * Returns all payee locations for the specified payee
     * @summary List locations for a payee
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {string} payee_id - id of payee
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    getPayeeLocationsByPayee(budget_id, payee_id, options) {
        return exports.PayeeLocationsApiFp(this.configuration).getPayeeLocationsByPayee(budget_id, payee_id, options)();
    }
}
exports.PayeeLocationsApi = PayeeLocationsApi;
/**
 * PayeesApi - fetch parameter creator
 * @export
 */
exports.PayeesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns single payee
         * @summary Single payee
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} payee_id - The id of the payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budget_id, payee_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getPayeeById.');
            }
            // verify required parameter 'payee_id' is not null or undefined
            if (payee_id === null || payee_id === undefined) {
                throw new RequiredError('payee_id', 'Required parameter payee_id was null or undefined when calling getPayeeById.');
            }
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payee_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budget_id, last_knowledge_of_server, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getPayees.');
            }
            const localVarPath = `/budgets/{budget_id}/payees`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (last_knowledge_of_server !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = last_knowledge_of_server;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PayeesApi - functional programming interface
 * @export
 */
exports.PayeesApiFp = function (configuration) {
    return {
        /**
         * Returns single payee
         * @summary Single payee
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} payee_id - The id of the payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budget_id, payee_id, options) {
            const localVarFetchArgs = exports.PayeesApiFetchParamCreator(configuration).getPayeeById(budget_id, payee_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budget_id, last_knowledge_of_server, options) {
            const localVarFetchArgs = exports.PayeesApiFetchParamCreator(configuration).getPayees(budget_id, last_knowledge_of_server, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * PayeesApi - factory interface
 * @export
 */
exports.PayeesApiFactory = function (configuration) {
    return {
        /**
         * Returns single payee
         * @summary Single payee
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} payee_id - The id of the payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budget_id, payee_id, options) {
            return exports.PayeesApiFp(configuration).getPayeeById(budget_id, payee_id, options)();
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budget_id, last_knowledge_of_server, options) {
            return exports.PayeesApiFp(configuration).getPayees(budget_id, last_knowledge_of_server, options)();
        },
    };
};
/**
 * PayeesApi - object-oriented interface
 * @export
 * @class PayeesApi
 * @extends {BaseAPI}
 */
class PayeesApi extends BaseAPI {
    /**
     * Returns single payee
     * @summary Single payee
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {string} payee_id - The id of the payee
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeesApi
     */
    getPayeeById(budget_id, payee_id, options) {
        return exports.PayeesApiFp(this.configuration).getPayeeById(budget_id, payee_id, options)();
    }
    /**
     * Returns all payees
     * @summary List payees
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeesApi
     */
    getPayees(budget_id, last_knowledge_of_server, options) {
        return exports.PayeesApiFp(this.configuration).getPayees(budget_id, last_knowledge_of_server, options)();
    }
}
exports.PayeesApi = PayeesApi;
/**
 * ScheduledTransactionsApi - fetch parameter creator
 * @export
 */
exports.ScheduledTransactionsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} scheduled_transaction_id - The id of the scheduled transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budget_id, scheduled_transaction_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getScheduledTransactionById.');
            }
            // verify required parameter 'scheduled_transaction_id' is not null or undefined
            if (scheduled_transaction_id === null || scheduled_transaction_id === undefined) {
                throw new RequiredError('scheduled_transaction_id', 'Required parameter scheduled_transaction_id was null or undefined when calling getScheduledTransactionById.');
            }
            const localVarPath = `/budgets/{budget_id}/scheduled_transactions/{scheduled_transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"scheduled_transaction_id"}}`, encodeURIComponent(String(scheduled_transaction_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budget_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getScheduledTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/scheduled_transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ScheduledTransactionsApi - functional programming interface
 * @export
 */
exports.ScheduledTransactionsApiFp = function (configuration) {
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} scheduled_transaction_id - The id of the scheduled transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budget_id, scheduled_transaction_id, options) {
            const localVarFetchArgs = exports.ScheduledTransactionsApiFetchParamCreator(configuration).getScheduledTransactionById(budget_id, scheduled_transaction_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budget_id, options) {
            const localVarFetchArgs = exports.ScheduledTransactionsApiFetchParamCreator(configuration).getScheduledTransactions(budget_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * ScheduledTransactionsApi - factory interface
 * @export
 */
exports.ScheduledTransactionsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} scheduled_transaction_id - The id of the scheduled transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budget_id, scheduled_transaction_id, options) {
            return exports.ScheduledTransactionsApiFp(configuration).getScheduledTransactionById(budget_id, scheduled_transaction_id, options)();
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budget_id, options) {
            return exports.ScheduledTransactionsApiFp(configuration).getScheduledTransactions(budget_id, options)();
        },
    };
};
/**
 * ScheduledTransactionsApi - object-oriented interface
 * @export
 * @class ScheduledTransactionsApi
 * @extends {BaseAPI}
 */
class ScheduledTransactionsApi extends BaseAPI {
    /**
     * Returns a single scheduled transaction
     * @summary Single scheduled transaction
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {string} scheduled_transaction_id - The id of the scheduled transaction
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof ScheduledTransactionsApi
     */
    getScheduledTransactionById(budget_id, scheduled_transaction_id, options) {
        return exports.ScheduledTransactionsApiFp(this.configuration).getScheduledTransactionById(budget_id, scheduled_transaction_id, options)();
    }
    /**
     * Returns all scheduled transactions
     * @summary List scheduled transactions
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof ScheduledTransactionsApi
     */
    getScheduledTransactions(budget_id, options) {
        return exports.ScheduledTransactionsApiFp(this.configuration).getScheduledTransactions(budget_id, options)();
    }
}
exports.ScheduledTransactionsApi = ScheduledTransactionsApi;
/**
 * TransactionsApi - fetch parameter creator
 * @export
 */
exports.TransactionsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates a single transaction or multiple transactions.  If you provide a body containing a 'transaction' object, a single transaction will be created and if you provide a body containing a 'transactions' array, multiple transactions will be created.
         * @summary Create a single transaction or multiple transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {SaveTransactionsWrapper} data - The transaction or transactions to create.  To create a single transaction you can specify a value for the 'transaction' object and to create multiple transactions you can specify an array of 'transactions'.  It is expected that you will only provide a value for one of these objects.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        createTransaction(budget_id, data, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling createTransaction.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data', 'Required parameter data was null or undefined when calling createTransaction.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(data || {});
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} transaction_id - The id of the transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionById(budget_id, transaction_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getTransactionById.');
            }
            // verify required parameter 'transaction_id' is not null or undefined
            if (transaction_id === null || transaction_id === undefined) {
                throw new RequiredError('transaction_id', 'Required parameter transaction_id was null or undefined when calling getTransactionById.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions/{transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transaction_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budget_id, since_date, type, last_knowledge_of_server, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (since_date !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(since_date);
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (last_knowledge_of_server !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = last_knowledge_of_server;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} account_id - The id of the account
         * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budget_id, account_id, since_date, type, last_knowledge_of_server, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getTransactionsByAccount.');
            }
            // verify required parameter 'account_id' is not null or undefined
            if (account_id === null || account_id === undefined) {
                throw new RequiredError('account_id', 'Required parameter account_id was null or undefined when calling getTransactionsByAccount.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts/{account_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(account_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (since_date !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(since_date);
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (last_knowledge_of_server !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = last_knowledge_of_server;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} category_id - The id of the category
         * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budget_id, category_id, since_date, type, last_knowledge_of_server, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getTransactionsByCategory.');
            }
            // verify required parameter 'category_id' is not null or undefined
            if (category_id === null || category_id === undefined) {
                throw new RequiredError('category_id', 'Required parameter category_id was null or undefined when calling getTransactionsByCategory.');
            }
            const localVarPath = `/budgets/{budget_id}/categories/{category_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(category_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (since_date !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(since_date);
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (last_knowledge_of_server !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = last_knowledge_of_server;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} payee_id - The id of the payee
         * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByPayee(budget_id, payee_id, since_date, type, last_knowledge_of_server, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getTransactionsByPayee.');
            }
            // verify required parameter 'payee_id' is not null or undefined
            if (payee_id === null || payee_id === undefined) {
                throw new RequiredError('payee_id', 'Required parameter payee_id was null or undefined when calling getTransactionsByPayee.');
            }
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payee_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (since_date !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(since_date);
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (last_knowledge_of_server !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = last_knowledge_of_server;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a transaction
         * @summary Updates an existing transaction
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} transaction_id - The id of the transaction
         * @param {SaveTransactionWrapper} data - The transaction to update
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateTransaction(budget_id, transaction_id, data, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling updateTransaction.');
            }
            // verify required parameter 'transaction_id' is not null or undefined
            if (transaction_id === null || transaction_id === undefined) {
                throw new RequiredError('transaction_id', 'Required parameter transaction_id was null or undefined when calling updateTransaction.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data', 'Required parameter data was null or undefined when calling updateTransaction.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions/{transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transaction_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(data || {});
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates multiple transactions, by 'id' or 'import_id'.
         * @summary Update multiple transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {SaveTransactionsWrapper} data - The transactions to update.  Optionally, transaction 'id' value(s) can be specified as null and an 'import_id' value can be provided which will allow transaction(s) to updated by their import_id.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateTransactions(budget_id, data, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling updateTransactions.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data', 'Required parameter data was null or undefined when calling updateTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(data || {});
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransactionsApi - functional programming interface
 * @export
 */
exports.TransactionsApiFp = function (configuration) {
    return {
        /**
         * Creates a single transaction or multiple transactions.  If you provide a body containing a 'transaction' object, a single transaction will be created and if you provide a body containing a 'transactions' array, multiple transactions will be created.
         * @summary Create a single transaction or multiple transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {SaveTransactionsWrapper} data - The transaction or transactions to create.  To create a single transaction you can specify a value for the 'transaction' object and to create multiple transactions you can specify an array of 'transactions'.  It is expected that you will only provide a value for one of these objects.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        createTransaction(budget_id, data, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).createTransaction(budget_id, data, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} transaction_id - The id of the transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionById(budget_id, transaction_id, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactionById(budget_id, transaction_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budget_id, since_date, type, last_knowledge_of_server, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactions(budget_id, since_date, type, last_knowledge_of_server, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} account_id - The id of the account
         * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budget_id, account_id, since_date, type, last_knowledge_of_server, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactionsByAccount(budget_id, account_id, since_date, type, last_knowledge_of_server, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} category_id - The id of the category
         * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budget_id, category_id, since_date, type, last_knowledge_of_server, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactionsByCategory(budget_id, category_id, since_date, type, last_knowledge_of_server, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} payee_id - The id of the payee
         * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByPayee(budget_id, payee_id, since_date, type, last_knowledge_of_server, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactionsByPayee(budget_id, payee_id, since_date, type, last_knowledge_of_server, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Updates a transaction
         * @summary Updates an existing transaction
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} transaction_id - The id of the transaction
         * @param {SaveTransactionWrapper} data - The transaction to update
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateTransaction(budget_id, transaction_id, data, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).updateTransaction(budget_id, transaction_id, data, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Updates multiple transactions, by 'id' or 'import_id'.
         * @summary Update multiple transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {SaveTransactionsWrapper} data - The transactions to update.  Optionally, transaction 'id' value(s) can be specified as null and an 'import_id' value can be provided which will allow transaction(s) to updated by their import_id.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateTransactions(budget_id, data, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).updateTransactions(budget_id, data, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * TransactionsApi - factory interface
 * @export
 */
exports.TransactionsApiFactory = function (configuration) {
    return {
        /**
         * Creates a single transaction or multiple transactions.  If you provide a body containing a 'transaction' object, a single transaction will be created and if you provide a body containing a 'transactions' array, multiple transactions will be created.
         * @summary Create a single transaction or multiple transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {SaveTransactionsWrapper} data - The transaction or transactions to create.  To create a single transaction you can specify a value for the 'transaction' object and to create multiple transactions you can specify an array of 'transactions'.  It is expected that you will only provide a value for one of these objects.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        createTransaction(budget_id, data, options) {
            return exports.TransactionsApiFp(configuration).createTransaction(budget_id, data, options)();
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} transaction_id - The id of the transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionById(budget_id, transaction_id, options) {
            return exports.TransactionsApiFp(configuration).getTransactionById(budget_id, transaction_id, options)();
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budget_id, since_date, type, last_knowledge_of_server, options) {
            return exports.TransactionsApiFp(configuration).getTransactions(budget_id, since_date, type, last_knowledge_of_server, options)();
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} account_id - The id of the account
         * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budget_id, account_id, since_date, type, last_knowledge_of_server, options) {
            return exports.TransactionsApiFp(configuration).getTransactionsByAccount(budget_id, account_id, since_date, type, last_knowledge_of_server, options)();
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} category_id - The id of the category
         * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budget_id, category_id, since_date, type, last_knowledge_of_server, options) {
            return exports.TransactionsApiFp(configuration).getTransactionsByCategory(budget_id, category_id, since_date, type, last_knowledge_of_server, options)();
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} payee_id - The id of the payee
         * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByPayee(budget_id, payee_id, since_date, type, last_knowledge_of_server, options) {
            return exports.TransactionsApiFp(configuration).getTransactionsByPayee(budget_id, payee_id, since_date, type, last_knowledge_of_server, options)();
        },
        /**
         * Updates a transaction
         * @summary Updates an existing transaction
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {string} transaction_id - The id of the transaction
         * @param {SaveTransactionWrapper} data - The transaction to update
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateTransaction(budget_id, transaction_id, data, options) {
            return exports.TransactionsApiFp(configuration).updateTransaction(budget_id, transaction_id, data, options)();
        },
        /**
         * Updates multiple transactions, by 'id' or 'import_id'.
         * @summary Update multiple transactions
         * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
         * @param {SaveTransactionsWrapper} data - The transactions to update.  Optionally, transaction 'id' value(s) can be specified as null and an 'import_id' value can be provided which will allow transaction(s) to updated by their import_id.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateTransactions(budget_id, data, options) {
            return exports.TransactionsApiFp(configuration).updateTransactions(budget_id, data, options)();
        },
    };
};
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
class TransactionsApi extends BaseAPI {
    /**
     * Creates a single transaction or multiple transactions.  If you provide a body containing a 'transaction' object, a single transaction will be created and if you provide a body containing a 'transactions' array, multiple transactions will be created.
     * @summary Create a single transaction or multiple transactions
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {SaveTransactionsWrapper} data - The transaction or transactions to create.  To create a single transaction you can specify a value for the 'transaction' object and to create multiple transactions you can specify an array of 'transactions'.  It is expected that you will only provide a value for one of these objects.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    createTransaction(budget_id, data, options) {
        return exports.TransactionsApiFp(this.configuration).createTransaction(budget_id, data, options)();
    }
    /**
     * Returns a single transaction
     * @summary Single transaction
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {string} transaction_id - The id of the transaction
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionById(budget_id, transaction_id, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactionById(budget_id, transaction_id, options)();
    }
    /**
     * Returns budget transactions
     * @summary List transactions
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
     * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
     * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactions(budget_id, since_date, type, last_knowledge_of_server, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactions(budget_id, since_date, type, last_knowledge_of_server, options)();
    }
    /**
     * Returns all transactions for a specified account
     * @summary List account transactions
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {string} account_id - The id of the account
     * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
     * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
     * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionsByAccount(budget_id, account_id, since_date, type, last_knowledge_of_server, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactionsByAccount(budget_id, account_id, since_date, type, last_knowledge_of_server, options)();
    }
    /**
     * Returns all transactions for a specified category
     * @summary List category transactions
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {string} category_id - The id of the category
     * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
     * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
     * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionsByCategory(budget_id, category_id, since_date, type, last_knowledge_of_server, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactionsByCategory(budget_id, category_id, since_date, type, last_knowledge_of_server, options)();
    }
    /**
     * Returns all transactions for a specified payee
     * @summary List payee transactions
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {string} payee_id - The id of the payee
     * @param {Date} [since_date] - If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
     * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - If specified, only transactions of the specified type will be included. 'uncategorized' and 'unapproved' are currently supported.
     * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionsByPayee(budget_id, payee_id, since_date, type, last_knowledge_of_server, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactionsByPayee(budget_id, payee_id, since_date, type, last_knowledge_of_server, options)();
    }
    /**
     * Updates a transaction
     * @summary Updates an existing transaction
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {string} transaction_id - The id of the transaction
     * @param {SaveTransactionWrapper} data - The transaction to update
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    updateTransaction(budget_id, transaction_id, data, options) {
        return exports.TransactionsApiFp(this.configuration).updateTransaction(budget_id, transaction_id, data, options)();
    }
    /**
     * Updates multiple transactions, by 'id' or 'import_id'.
     * @summary Update multiple transactions
     * @param {string} budget_id - The id of the budget (\"last-used\" can also be used to specify the last used budget)
     * @param {SaveTransactionsWrapper} data - The transactions to update.  Optionally, transaction 'id' value(s) can be specified as null and an 'import_id' value can be provided which will allow transaction(s) to updated by their import_id.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    updateTransactions(budget_id, data, options) {
        return exports.TransactionsApiFp(this.configuration).updateTransactions(budget_id, data, options)();
    }
}
exports.TransactionsApi = TransactionsApi;
/**
 * UserApi - fetch parameter creator
 * @export
 */
exports.UserApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns authenticated user information
         * @summary User info
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getUser(options = {}) {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
exports.UserApiFp = function (configuration) {
    return {
        /**
         * Returns authenticated user information
         * @summary User info
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getUser(options) {
            const localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).getUser(options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
exports.UserApiFactory = function (configuration) {
    return {
        /**
         * Returns authenticated user information
         * @summary User info
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getUser(options) {
            return exports.UserApiFp(configuration).getUser(options)();
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends BaseAPI {
    /**
     * Returns authenticated user information
     * @summary User info
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(options) {
        return exports.UserApiFp(this.configuration).getUser(options)();
    }
}
exports.UserApi = UserApi;
